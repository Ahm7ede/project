// Supabase configuration
const SUPABASE_URL = 'https://ikbwdlfjsxglfmydupsk.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlrYndkbGZqc3hnbGZteWR1cHNrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA5MDg1NTUsImV4cCI6MjA1NjQ4NDU1NX0.NCc_38naVWc-JHO1qkcXdBU1BEqeZJfuxMrQwg07dD0';

// App state
let supabase;
let map;
let currentFloor = 0; // Starting with floor 0 as default
let currentCategory = null;
let allPoints = [];
let markerLayers = {};
let categoryButtons = {};
let visibleMarkers = [];

// Campus center coordinates (based on provided points)
const CAMPUS_CENTER = [9.99310, 76.35840]; // [latitude, longitude]
const CAMPUS_ZOOM = 18;
const MAX_ZOOM = 22; // Higher max zoom level
const LABEL_ZOOM_LEVEL = 19; // Zoom level at which labels appear

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
  initializeSplashScreen();
  initializeSupabase();
  initializeMap();
  initializeUI();
  
  // Fetch points after a short delay to ensure map is loaded
  setTimeout(fetchPoints, 1000);
});


// Modify the initializeSplashScreen function to zoom to mbentrance
function initializeSplashScreen() {
  // Regular transition
  setTimeout(() => {
    document.getElementById('splash').style.opacity = '0';
    document.getElementById('app').style.opacity = '1';
    
    setTimeout(() => {
      document.getElementById('splash').style.display = 'none';
      
      // Show welcome message and zoom to entrance
      focusOnEntrance();
    }, 1000);
  }, 2000);
  
  // Backup transition in case animation fails
  setTimeout(() => {
    document.getElementById('splash').style.display = 'none';
    document.getElementById('app').style.opacity = '1';
    
    // Show welcome message and zoom to entrance as backup
    setTimeout(() => {
      focusOnEntrance();
    }, 500);
  }, 3500);
  
  // Expand POI panel after splash
  setTimeout(() => {
    document.getElementById('poiPanel').classList.add('expanded');
  }, 3000);
}

// New function to focus on entrance and show welcome message
function focusOnEntrance() {
  // Show the welcome message
  showWelcomeMessage("You are at Main Building Entrance");
  
  // Find the entrance point
  const entrancePoint = findEntrancePoint();
  
  if (entrancePoint) {
    // Zoom to the entrance point
    map.setView([entrancePoint.latitude, entrancePoint.longitude], LABEL_ZOOM_LEVEL);
    
    // Show a special entrance pin marker
    createEntranceMarker(entrancePoint);
  }
}

// Find entrance point in current data
function findEntrancePoint() {
  // Try to find it in the loaded points
  let entrance = allPoints.find(p => 
    p.name && p.name.toLowerCase() === 'mbentrance' && p.floor === currentFloor
  );
  
  // If not found, create a default entrance point
  if (!entrance) {
    entrance = {
      id: 'entrance-default',
      name: 'mbentrance',
      latitude: 9.99310,
      longitude: 76.35838,
      floor: 0,
      type: 'entrance'
    };
    
    // Add to allPoints so it's available for searching later
    allPoints.push(entrance);
  }
  
  return entrance;
}

// Create a special marker for the entrance
function createEntranceMarker(point) {
  // Remove existing entrance marker if any
  if (window.entranceMarker && map.hasLayer(window.entranceMarker)) {
    map.removeLayer(window.entranceMarker);
  }
  
  // Create a special marker for the entrance
  const entranceIcon = L.divIcon({
    className: 'entrance-marker-icon',
    html: '<div class="entrance-pin"><div class="entrance-pin-inner"></div></div>',
    iconSize: [30, 30],
    iconAnchor: [15, 30]
  });
  
  // Create the marker
  window.entranceMarker = L.marker([point.latitude, point.longitude], {
    icon: entranceIcon,
    zIndexOffset: 1000 // Put it above other markers
  }).addTo(map);
  
  // Add a pulsing animation
  window.entranceMarker.getElement().classList.add('pulsing');
  
  // Add popup
  window.entranceMarker.bindPopup(`
    <div class="entrance-popup">
      <h3>Main Building Entrance</h3>
      <p>You are here</p>
    </div>
  `);
  
  // Open popup after a delay
  setTimeout(() => {
    window.entranceMarker.openPopup();
  }, 1000);
  
  // Keep entrance marker reference for later use
  return window.entranceMarker;
}

// Modified function to show welcome message at the top
function showWelcomeMessage(message) {
  // Create welcome message container
  const welcomeContainer = document.createElement('div');
  welcomeContainer.className = 'welcome-message';
  welcomeContainer.textContent = message;
  
  // Add to body
  document.body.appendChild(welcomeContainer);
  
  // Trigger animation
  setTimeout(() => {
    welcomeContainer.classList.add('visible');
  }, 100);
  
  // Auto-dismiss after a few seconds
  setTimeout(() => {
    welcomeContainer.classList.remove('visible');
    
    // Remove from DOM after fade out
    setTimeout(() => {
      document.body.removeChild(welcomeContainer);
    }, 500);
  }, 4000);
}
// Initialize Supabase connection
function initializeSupabase() {
  try {
    supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    console.log('Supabase client initialized');
  } catch (error) {
    console.error('Error initializing Supabase:', error);
  }
}

// Initialize Leaflet map
function initializeMap() {
  // Create map centered on campus with higher max zoom
  map = L.map('map', {
    center: CAMPUS_CENTER,
    zoom: CAMPUS_ZOOM,
    maxZoom: MAX_ZOOM,
    zoomSnap: 0.5,
    zoomDelta: 0.5
  });
  
  // Add OpenStreetMap base layer with better zoom support
  // Use a tile server that supports higher zoom levels
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors',
    maxZoom: MAX_ZOOM,
    // Add fallback options for high zoom levels
    maxNativeZoom: 19, // Most OSM tiles max out at 19
    noWrap: true, // Prevents tiles from wrapping at extreme zoom levels
  }).addTo(map);
  
  // Listen for zoom and move events to update labels
  map.on('zoomend', updateAllLabels);
  map.on('moveend', updateAllLabels);
  map.on('move', updateAllLabels);
  
  // Mark the active floor button
  document.querySelector(`.floor-button[data-floor="${currentFloor}"]`).classList.add('active');
}

// Update all labels positions and visibility
function updateAllLabels() {
  const currentZoom = map.getZoom();
  const showLabels = currentZoom >= LABEL_ZOOM_LEVEL;
  
  // Update all visible markers' labels
  visibleMarkers.forEach(marker => {
    if (marker.label) {
      if (showLabels) {
        marker.label.style.display = 'block';
        updateLabelPosition(marker);
      } else {
        marker.label.style.display = 'none';
      }
    }
  });
}

// Update position of a single label with better positioning
function updateLabelPosition(marker) {
  if (!marker.label || !marker.getLatLng) return;
  
  const position = map.latLngToContainerPoint(marker.getLatLng());
  const labelWidth = marker.label.offsetWidth || 100; // Default if not rendered yet
  
  // Position label above marker with proper centering
  marker.label.style.left = `${position.x}px`;
  marker.label.style.top = `${position.y - 15}px`;
  marker.label.style.transform = 'translate(-50%, -100%)';
}

// Initialize UI event listeners
function initializeUI() {
  // POI panel toggle
  const poiPanel = document.getElementById('poiPanel');
  const poiHandle = document.getElementById('poiHandle');
  poiHandle.addEventListener('click', () => {
    poiPanel.classList.toggle('expanded');
  });
  
  // Floor selector buttons
  document.querySelectorAll('.floor-button').forEach(button => {
    button.addEventListener('click', async function() {
      // Update UI
      document.querySelectorAll('.floor-button').forEach(btn => 
        btn.classList.remove('active')
      );
      this.classList.add('active');
      
      // Update state
      currentFloor = parseInt(this.dataset.floor);
      
      // Show loading indicator
      document.getElementById('loadingIndicator').style.display = 'block';
      
      // Fetch points for the selected floor
      await fetchFloorPoints(currentFloor);
      
      // Hide loading indicator
      document.getElementById('loadingIndicator').style.display = 'none';
    });
  });
  
  // Category filter buttons
  document.querySelectorAll('.poi-button').forEach(button => {
    const category = button.dataset.category;
    categoryButtons[category] = button;
    
    button.addEventListener('click', function() {
      // Toggle category filter
      currentCategory = currentCategory === category ? null : category;
      
      // Update UI
      document.querySelectorAll('.poi-button').forEach(btn => 
        btn.classList.remove('active')
      );
      if (currentCategory) {
        this.classList.add('active');
      }
      
      // Update map
      filterAndDisplayPoints();
    });
  });
  
  // Search input handling
  document.querySelector('.search-input').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      const searchValue = this.value.trim().toLowerCase();
      if (searchValue) {
        searchPoints(searchValue);
      }
    }
  });
  
  // Create a container for point labels
  const mapContainer = document.querySelector('.map-container');
  let labelsContainer = document.getElementById('map-labels-container');
  
  if (!labelsContainer) {
    labelsContainer = document.createElement('div');
    labelsContainer.id = 'map-labels-container';
    labelsContainer.style.position = 'absolute';
    labelsContainer.style.top = '0';
    labelsContainer.style.left = '0';
    labelsContainer.style.width = '100%';
    labelsContainer.style.height = '100%';
    labelsContainer.style.pointerEvents = 'none';
    labelsContainer.style.zIndex = '650';
    mapContainer.appendChild(labelsContainer);
  }
}

// Fetch points from Supabase (initial load)
async function fetchPoints() {
  try {
    // Show loading indicator
    document.getElementById('loadingIndicator').style.display = 'block';
    
    // Fetch data from Supabase for current floor (more efficient than loading all points)
    const { data, error } = await supabase
      .from('points')
      .select('*')
      .eq('floor', currentFloor);
    
    if (error) throw error;
    
    // Store points
    allPoints = data || [];
    console.log(`Fetched ${allPoints.length} points for floor ${currentFloor} from Supabase`);
    
    // Initialize marker layers for each category
    createMarkerLayers();
    
    // Display points
    filterAndDisplayPoints();
    
    // Fit map to show all points from current floor
    fitMapToBounds();
    
  } catch (error) {
    console.error('Error fetching points:', error);
    
    // Use fallback demo data if needed
    if (!allPoints.length) {
      allPoints = getDemoPoints().filter(p => p.floor === currentFloor);
      createMarkerLayers();
      filterAndDisplayPoints();
      fitMapToBounds();
    }
  } finally {
    // Hide loading indicator
    document.getElementById('loadingIndicator').style.display = 'none';
  }
}

// Fetch points for a specific floor
async function fetchFloorPoints(floor) {
  try {
    // Fetch data from Supabase filtered by floor
    const { data, error } = await supabase
      .from('points')
      .select('*')
      .eq('floor', floor);
    
    if (error) throw error;
    
    // Store points
    allPoints = data || [];
    console.log(`Fetched ${allPoints.length} points for floor ${floor} from Supabase`);
    
    // Initialize marker layers for each category
    createMarkerLayers();
    
    // Display points
    filterAndDisplayPoints();
    
    // Fit map to show all points from current floor
    fitMapToBounds();
    
  } catch (error) {
    console.error(`Error fetching points for floor ${floor}:`, error);
    
    // Use fallback demo data if needed
    if (!allPoints.length) {
      allPoints = getDemoPoints().filter(p => p.floor === floor);
      createMarkerLayers();
      filterAndDisplayPoints();
      fitMapToBounds();
    }
  }
}

// Create marker layer groups for each category
function createMarkerLayers() {
  // Clear existing layers and markers
  Object.values(markerLayers).forEach(layer => {
    if (map.hasLayer(layer)) {
      map.removeLayer(layer);
    }
  });
  markerLayers = {};
  
  // Clear all existing labels
  const labelsContainer = document.getElementById('map-labels-container');
  if (labelsContainer) {
    labelsContainer.innerHTML = '';
  }
  
  // Reset visible markers array
  visibleMarkers = [];
  
  // Get unique categories (using 'type' field from the points table)
  const categories = [...new Set(allPoints.map(p => p.type))];
  
  // Create a layer group for each category
  categories.forEach(category => {
    if (category) {
      markerLayers[category] = L.layerGroup();
    }
  });
  
  // Create a layer for points without category
  markerLayers['uncategorized'] = L.layerGroup();
  
  // Create markers for each point
  allPoints.forEach(point => {
    // Skip if no coordinates
    if (!point.latitude || !point.longitude) return;
    
    // Create marker
    const marker = createMarker(point);
    
    // Add to appropriate layer
    const layerKey = point.type || 'uncategorized';
    if (markerLayers[layerKey]) {
      markerLayers[layerKey].addLayer(marker);
    } else {
      markerLayers[layerKey] = L.layerGroup([marker]);
    }
    
    // Store reference to the marker
    point.marker = marker;
  });
}

// Create a marker for a point
function createMarker(point) {
  // Create marker with custom color based on category (smaller radius)
  const marker = L.circleMarker([point.latitude, point.longitude], {
    radius: 5, // Smaller radius for markers
    fillColor: getCategoryColor(point.type),
    color: '#fff',
    weight: 1,
    opacity: 1,
    fillOpacity: 0.8
  });
  
  // Add popup with point info
  marker.bindPopup(`
    <div class="point-popup">
      <h3>${point.name || 'Unnamed Point'}</h3>
      <p>Category: ${point.type || 'None'}</p>
      <p>Floor: ${point.floor || 'N/A'}</p>
      <p>Location: ${point.latitude.toFixed(6)}, ${point.longitude.toFixed(6)}</p>
    </div>
  `);
  
  // Add additional properties to marker for easy reference
  marker.pointData = point;
  marker.floor = point.floor;
  marker.category = point.type || 'uncategorized';
  
  // Create a label for this marker
  createLabelForMarker(marker);
  
  return marker;
}

// Create a label element for a marker
function createLabelForMarker(marker) {
  const labelsContainer = document.getElementById('map-labels-container');
  if (!labelsContainer) return;
  
  const point = marker.pointData;
  
  // Create the label element
  const label = document.createElement('div');
  label.className = 'point-label';
  label.textContent = point.name || 'Unnamed';
  label.style.display = 'none'; // Initially hidden
  label.style.position = 'absolute'; // Ensure position is absolute
  
  // Add the label to container
  labelsContainer.appendChild(label);
  
  // Store reference to the label on the marker
  marker.label = label;
  
  // Set initial position
  updateLabelPosition(marker);
}

// Filter and display points based on current floor and category
function filterAndDisplayPoints() {
  // Remove all layers from map first
  Object.values(markerLayers).forEach(layer => {
    if (map.hasLayer(layer)) {
      map.removeLayer(layer);
    }
  });
  
  // Clear the visible markers array
  visibleMarkers = [];
  
  // Create a set of categories present in the filtered points
  const availableCategories = new Set(allPoints.map(p => p.type).filter(Boolean));
  
  // Update category buttons (disable if no points in that category)
  Object.entries(categoryButtons).forEach(([category, button]) => {
    button.disabled = !availableCategories.has(category);
    button.style.opacity = button.disabled ? '0.5' : '1';
  });
  
  // If current category is filtered out, reset it
  if (currentCategory && !availableCategories.has(currentCategory)) {
    currentCategory = null;
    document.querySelectorAll('.poi-button').forEach(btn => btn.classList.remove('active'));
  }
  
  // Add filtered layers to map and collect visible markers
  Object.entries(markerLayers).forEach(([category, layer]) => {
    // If no category filter or matches current category
    if (!currentCategory || category === currentCategory) {
      // Add the layer to the map
      map.addLayer(layer);
      
      // Find all markers in this layer and add to visible markers
      layer.eachLayer(marker => {
        visibleMarkers.push(marker);
      });
    }
  });
  
  // Update labels visibility and positions
  updateAllLabels();
}

// Fit map to show all points
function fitMapToBounds() {
  // Get markers from current floor
  const floorPoints = allPoints.filter(point => point.floor === currentFloor);
  
  if (floorPoints.length > 0) {
    // Calculate bounds
    const latitudes = floorPoints.map(p => p.latitude).filter(Boolean);
    const longitudes = floorPoints.map(p => p.longitude).filter(Boolean);
    
    if (latitudes.length > 0 && longitudes.length > 0) {
      const southWest = L.latLng(
        Math.min(...latitudes) - 0.0005, 
        Math.min(...longitudes) - 0.0005
      );
      const northEast = L.latLng(
        Math.max(...latitudes) + 0.0005, 
        Math.max(...longitudes) + 0.0005
      );
      const bounds = L.latLngBounds(southWest, northEast);
      
      map.fitBounds(bounds);
      return;
    }
  }
  
  // Default to campus center if no points or bounds
  map.setView(CAMPUS_CENTER, CAMPUS_ZOOM);
}

// Search for points by name or category
function searchPoints(query) {
  const found = allPoints.find(point => 
    (point.name && point.name.toLowerCase().includes(query)) || 
    (point.type && point.type.toLowerCase().includes(query))
  );
  
  if (found) {
    // Switch to the correct floor if needed
    if (found.floor !== currentFloor) {
      currentFloor = found.floor;
      document.querySelectorAll('.floor-button').forEach(btn => {
        btn.classList.remove('active');
        if (parseInt(btn.dataset.floor) === currentFloor) {
          btn.classList.add('active');
        }
      });
    }
    
    // Clear category filter
    currentCategory = null;
    document.querySelectorAll('.poi-button').forEach(btn => {
      btn.classList.remove('active');
    });
    
    // Update display
    filterAndDisplayPoints();
    
    // Center map on found point with higher zoom for better visibility
    map.setView([found.latitude, found.longitude], LABEL_ZOOM_LEVEL + 1);
    
    // Create temporary highlight effect
    const highlightMarker = L.circleMarker([found.latitude, found.longitude], {
      radius: 15,
      color: '#3498db',
      weight: 3,
      opacity: 0.8,
      fillColor: '#3498db',
      fillOpacity: 0.3,
      className: 'highlight-marker'
    }).addTo(map);
    
    // Add pulsing animation via CSS
    const markerElement = highlightMarker.getElement();
    if (markerElement) {
      markerElement.style.animation = 'pulse 1.5s infinite';
    }
    
    // Remove highlight after animation
    setTimeout(() => {
      map.removeLayer(highlightMarker);
    }, 3000);
    
    // Open popup if marker exists
    if (found.marker) {
      setTimeout(() => {
        found.marker.openPopup();
      }, 500);
    }
  } else {
    alert(`No location found matching "${query}"`);
  }
}

// Get color for different categories
function getCategoryColor(category) {
  const colors = {
    'elevator': '#e74c3c',
    'canteen': '#f39c12',
    'washroom': '#3498db',
    'library': '#9b59b6',
    'virtual': '#2ecc71',
    'default': '#95a5a6'
  };
  
  return colors[category] || colors.default;
}

// Fallback demo points data
function getDemoPoints() {
  return [
    { id: 1, floor: 0, name: 'Library', longitude: 76.3585349, latitude: 9.993269935, type: 'virtual' },
    { id: 2, floor: 0, name: 'Multimedia', longitude: 76.35841714, latitude: 9.99305027, type: 'virtual' },
    { id: 3, floor: 0, name: 'Sunyalab', longitude: 76.35842629, latitude: 9.992952018, type: 'virtual' },
    { id: 4, floor: 0, name: 'Staff Room', longitude: 76.35832774, latitude: 9.993041686, type: 'virtual' }
  ];
}

// Handle window resize
window.addEventListener('resize', () => {
  if (map) {
    map.invalidateSize();
    // Update labels after resize
    updateAllLabels();
  }
});